\chapter{Wnioski}
Głównym wnioskiem wypływającym z analizy wyników przeprowadzonych symulacji jest to, że algorytmy Flood oraz SPIN wykazują jednakowe tempo spadku liczby aktywnych czujników, niezależne od rozmiaru danych oraz odstępu między pakietami. Jest to odkrycie o tyleż znaczące, ponieważ powyższe dwa protokoły są zdecydowanie różne od siebie. SPIN został zaprojektowany w celu uzyskania lepszych wyników niż przy rozwiązaniu naiwnym (protokół Flood). W~praktyce jednak zarówno węzły wykorzystujące protokół Flood, jak i te używające SPIN są w ciągłym trybie nasłuchiwania, w którym zużycie energii jest dużo większe, niż w trybie uśpienia. W~publikacjach najczęściej przyjmowany jest model teoretyczny radioodbiornika, w~którym zużycie energii uzależnione jest jedynie od liczby odebranych, bądź wysłanych bajtów oraz odległości pomiędzy nadajnikiem i odbiornikiem. Pomijany jest przy tym fakt, że zużycie energii przez węzeł w trybie bezczynności (idle state) jest porównywalne z tym podczas odbierania pakietów \cite{Odey2013}.
W~przypadku SPIN i Flood większość czujników wyłącza się w bardzo krótkim przedziale czasowym. Oznacza to, że zużycie energii przez węzły jest równomierne (wszystkie czujniki są przez cały czas swojej aktywności w trybie nasłuchiwania - w przeciwieństwie do rodziny alogrytmów typu LEACH, w których występują okresy ''uśpienia'' czujników).

Sieci korzystające z~protokołów LEACH, ALEACH i~LEACH DCHS wykazują wyraźnie dłuższe działanie niż sieci używające Flood i~SPIN.
Różnice zacierają się dla większych rozmiarów pakietów i~mniejszych odstępów czasu pomiędzy pakietami.

Wymienione powyżej różnice pomiędzy grupami protokołów były wyraźniejsze dla sieci o~większej liczbie węzłów.

W ramach pracy przeprowadzony został zestaw symulacji z~możliwie dokładnymi scenariuszami, na jakich przeprowadzenie pozwala typowy komputer osobisty w~rozsądnym czasie (~1 miesiąc ciągłej pracy). Zrealizowanych zostało 17 765 eksperymentów, które wygenerowały 291GB surowych danych. Przetworzenie ich wymagało dodatkowych nakładów obliczeniowych oraz pracy przy utworzeniu skryptu w~języku Ruby, natomiast ich analiza oraz wizualizacja została wykonana przy użyciu skryptu w~języku R napisanego przez autora pracy.


Założone cele projektu zostały osiągnięte, jednakże jednocześnie otwarte są dalsze potencjalne kierunki jego rozwoju. Możliwe jest stworzenie dokładniejszych modeli symulacyjnych poprzez uwzględnienie oraz implementację symulacji badanego procesu. W~takim przypadku możliwe stałoby się stworzenie scenariuszy symulacyjnych uwzględniające generowanie nowych pakietów z~danymi przez węzły sieci, które jest wyzwalane zdarzeniami.
Stworzona w~ramach projektu biblioteka symulacyjna stanowi doskonałą bazę do implementacji większej liczby różnorodnych protokołów trasowania. Możliwa dzięki temu jest weryfikacja oraz testy nowych protokołów trasowania, dla których, z~racji wysokich kosztów, nie są przeprowadzane dokładne testy wydajnościowe oraz porównawcze. Przy odpowiednio dużej bazie zaimplementowanych protokołów możliwa staje się ich rzetelna weryfikacja.

Przeprowadzenie takich rozległych testów wymagałoby przygotowania dokładniejszych scenariuszy testowych niż te zaproponowane w~niniejszej pracy. Wiązałoby się to również z~koniecznością wykorzystania chmury obliczeniowej.

